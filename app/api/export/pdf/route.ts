import { type NextRequest, NextResponse } from "next/server"
import { neon } from "@neondatabase/serverless"
import { getServerSession } from "next-auth"
import jsPDF from "jspdf"

const sql = neon(process.env.DATABASE_URL!)

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession()
    if (!session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const { idea_id } = await request.json()

    // Get idea and validation report
    const ideaResult = await sql`
      SELECT 
        i.*,
        vr.*,
        u.email as user_email,
        u.full_name as user_name
      FROM ideas i
      JOIN users u ON i.user_id = u.id
      LEFT JOIN validation_reports vr ON i.id = vr.idea_id
      WHERE i.id = ${idea_id} AND u.email = ${session.user.email}
    `

    if (ideaResult.length === 0) {
      return NextResponse.json({ error: "Idea not found" }, { status: 404 })
    }

    const idea = ideaResult[0]

    // Create PDF
    const pdf = new jsPDF()
    const pageWidth = pdf.internal.pageSize.width
    const margin = 20
    let yPosition = margin

    // Helper function to add text
    const addText = (text: string, fontSize = 12, isBold = false) => {
      pdf.setFontSize(fontSize)
      if (isBold) {
        pdf.setFont(undefined, "bold")
      } else {
        pdf.setFont(undefined, "normal")
      }

      const lines = pdf.splitTextToSize(text, pageWidth - 2 * margin)
      pdf.text(lines, margin, yPosition)
      yPosition += lines.length * (fontSize * 0.4) + 5

      if (yPosition > pdf.internal.pageSize.height - margin) {
        pdf.addPage()
        yPosition = margin
      }
    }

    // Generate PDF content
    addText("FutureValidate - Startup Idea Validation Report", 20, true)
    yPosition += 10

    addText(`Idea Title: ${idea.title}`, 16, true)
    addText(`Industry: ${idea.industry}`)
    addText(`Description: ${idea.description}`)
    yPosition += 10

    if (idea.viability_score) {
      addText(`Viability Score: ${idea.viability_score}/10`, 14, true)
      yPosition += 10

      // Add market analysis
      if (idea.tam_data) {
        const tamData = JSON.parse(idea.tam_data)
        addText("Market Analysis", 16, true)
        addText(`Total Addressable Market: $${(tamData.total_market / 1000000000).toFixed(1)}B`)
        addText(`Market Growth Rate: ${tamData.growth_rate}% CAGR`)
        yPosition += 10
      }

      // Add SWOT analysis
      if (idea.swot_analysis) {
        const swot = JSON.parse(idea.swot_analysis)
        addText("SWOT Analysis", 16, true)

        addText("Strengths:", 12, true)
        swot.strengths.forEach((strength: string) => addText(`• ${strength}`))

        addText("Opportunities:", 12, true)
        swot.opportunities.forEach((opportunity: string) => addText(`• ${opportunity}`))
      }

      // Add business plan
      if (idea.business_plan) {
        addText("Executive Summary", 16, true)
        addText(idea.business_plan)
      }
    }

    // Footer
    pdf.setFontSize(8)
    pdf.text(
      `Generated by FutureValidate on ${new Date().toLocaleDateString()}`,
      margin,
      pdf.internal.pageSize.height - 10,
    )

    const pdfBuffer = Buffer.from(pdf.output("arraybuffer"))

    return new NextResponse(pdfBuffer, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="FutureValidate-${idea.title.replace(/[^a-zA-Z0-9]/g, "-")}.pdf"`,
      },
    })
  } catch (error) {
    console.error("PDF export error:", error)
    return NextResponse.json({ error: "Failed to generate PDF" }, { status: 500 })
  }
}
